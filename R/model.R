#' @title estPropInSpots
#'
#' @description Infer cellular proportions for spatial transcriptome (ST) spots.
#' @param sp.obj Seurat object of ST data.
#' @param sc.obj Seurat object of single-cell (SC) data.
#' @param hot.pvals A data.frame containing p-values generated by hotspot detection step.
#' @param sc.markers A list of markers of cell types.
#' @param knn K nearest cells used for estimating cellular proportions. Default: 5.
#' @param intercept Boolean indicating whether to use intercept for robust linear regression. Default: TRUE.
#' @param chunk.size Chunk size to determine downsampled ST data for estimating proportions. Default: 10000.
#' @return A data.frame of estimated cellular proportions in spots.

estPropInSpots <- function(sp.obj, sc.obj, hot.pvals, sc.markers, knn = 5, intercept = TRUE, chunk.size = 10000) {
    base.ref <-
        {
            AverageExpression(sc.obj, slot = "data", assay = "SCT")$SCT
        } %>%
        {
            .[unlist(sc.markers) %>% unique(), ]
        } %>%
        {
            log10(. + 1)
        }
    image.coord <- GetTissueCoordinates(sp.obj)[colnames(sp.obj), ]
    dist.lst <- lapply(levels(sp.obj), function(ident) {
        image.coord.tmp <- image.coord[Idents(sp.obj)[Idents(sp.obj) == ident] %>% names(), , drop = FALSE]
        dist.mat <- dbscan::kNN(na.omit(image.coord.tmp[, c(1, 2)]), k = min(knn, nrow(image.coord.tmp)))$id
    }) %>% `names<-`(levels(sp.obj))

    sp.expr <- GetAssayData(sp.obj, slot = "data", assay = "SCT")[rownames(base.ref), ]
    cell.types <- colnames(base.ref)
    colnames(base.ref) <- gsub(" |/|\\+|-|\\(|\\)", "_", colnames(base.ref))

    if (ncol(sp.obj) > chunk.size) {
        tar.spots <- downSamplSeurat(sp.obj, percent = round(chunk.size / ncol(sp.obj), 1)) %>% colnames()
    } else {
        tar.spots <- colnames(sp.obj)
    }
    w.mat <- ctypesOfClusters(sp.obj, hot.pvals)

    spot.prop <- future.apply::future_lapply(tar.spots, function(spot) {
        dist.mat <- dist.lst[[Idents(sp.obj)[spot]]]
        knn.spots <- dist.mat[spot, ] %>% rownames(dist.mat)[.]
        sp.expr.sub <- sp.expr[, knn.spots] %>%
            {
                10^.
            } %>%
            as.data.frame() %>%
            rowMeans() %>%
            {
                log10(.)
            }
        colnames(base.ref) <- paste0("X", colnames(base.ref))
        dat <- cbind.data.frame(base.ref, Bulk = sp.expr.sub)
        if (intercept) {
            w.coefs <- coef(MASS::rlm(Bulk ~ ., dat))
        } else {
            w.coefs <- coef(MASS::rlm(Bulk ~ . - 1, dat))
        }
        w.coefs[w.coefs < 0] <- 0
        coefs <- w.coefs[(intercept + 1):length(w.coefs)] / sum(w.coefs[(intercept + 1):length(w.coefs)])
        coefs <- coefs * w.mat[as.vector(Idents(sp.obj)[spot]), cell.types]
        coefs <- coefs / sum(coefs)
        names(coefs) <- cell.types
        return(coefs)
    }, future.seed = TRUE) %>%
        do.call(rbind, .) %>%
        as.data.frame() %>%
        `rownames<-`(tar.spots) %>%
        `colnames<-`(cell.types)
    spot.prop <- spot.prop[!is.na(rowSums(spot.prop)), ]
    return(spot.prop)
}

#' @title ctypesOfClusters
#'
#' @description Calculates weighted scores of cellular types across clusters based on spatial transcriptomics (ST) data and hotspot information.
#' @param sp.obj Seurat object of ST data.
#' @param hot.pvals A data.frame containing p-values generated by hotspot detection step.
#' @param p.cut Threashold value to filter out low-condfi
#' @return A data frame where each row represents a cluster and each column represents a cellular type, with values indicating weighted scores.

ctypesOfClusters <- function(sp.obj, hot.pvals, p.cut = 0.05) {
    hot.spts.tp <- hot.pvals < p.cut
    w.mat <- lapply(levels(sp.obj), function(cls) {
        spots <- colnames(sp.obj)[Idents(sp.obj) == cls]
        sub.pvals <- hot.spts.tp[spots, ]
        if (length(spots) > 1) {
            tmp.cnt <- colSums(sub.pvals)
        } else {
            tmp.cnt <- sum(sub.pvals)
        }
        w.gs <- scales::rescale(tmp.cnt %>% as.numeric(), to = c(0, 1))
    }) %>%
        do.call(rbind, .) %>%
        as.data.frame() %>%
        `rownames<-`(levels(sp.obj)) %>%
        `colnames<-`(colnames(hot.spts.tp))
    return(w.mat)
}

#' @title weightSimScore
#'
#' @description Applies weighted adjustment to similarity scores between spots and cell types based on provided adjustment weights and hotspot information.
#' @param out.sim Matrix or data frame of similarity scores between spots and cell types.
#' @param adj.w Weight matrix specifying adjustments for each spot and cell type combination.
#' @param spot.name Vector or list of spot names.
#' @param cell.names Vector or list of cell type names.
#' @param hot.spts A data frame indicating hotspot presence in spots and cell types.
#' @return Weighted similarity scores matrix where adjustments are applied based on provided weights and hotspot information.

weightSimScore <- function(out.sim, adj.w, spot.name, cell.names, hot.spts = NULL, p.cut = 0.01) {
    spot.name <- as.vector(spot.name) %>% `names<-`(names(spot.name))
    cell.names <- as.vector(cell.names) %>% `names<-`(names(cell.names))
    out.sim.sub <- out.sim[names(spot.name), names(cell.names)]
    if (ncol(adj.w) != ncol(hot.spts)) {
        adj.w.sub <- adj.w[names(spot.name), gsub("Pseudo_|_XYZ\\d+", "", names(cell.names))] %>% `colnames<-`(names(cell.names))
    } else {
        adj.w.sub <- adj.w[spot.name, cell.names] %>%
            `colnames<-`(names(cell.names)) %>%
            `rownames<-`(names(spot.name))
    }
    out.sim.w <-
        {
            out.sim.sub * adj.w.sub
        } %>% t()
    if (!is.null(hot.spts)) {
        hot.spts <- hot.spts <= p.cut
        hot.spts.flat <- hot.spts[names(spot.name), cell.names] %>%
            `colnames<-`(names(cell.names)) %>%
            t()
        idxes <- which(hot.spts.flat == FALSE)
        out.sim.w[idxes] <- out.sim.w[idxes] - 1
    }
    return(out.sim.w)
}

#' @title weigthNetProb
#'
#' @description Adjusts FNN predictions based on cell type proportions derived from SC and ST data, considering hotspot information.
#' @param netx.pred Matrix or data frame of network predictions.
#' @param sc.obj Seurat object of SC data.
#' @param sp.obj Seurat object of ST data.
#' @param hot.spts A data frame indicating hotspot presence in spots and cell types.
#' @return Adjusted network predictions matrix where weights are applied based on cell type proportions and hotspot information.

weigthNetProb <- function(netx.pred, sc.obj, sp.obj, hot.spts) {
    hot.spts <- hot.spts <= 0.01
    hot.spts.new <- cbind.data.frame(hot.spts, CLUSTER = Idents(sp.obj)[rownames(hot.spts)])
    cluster.summary <- hot.spts.new %>%
        pivot_longer(cols = -CLUSTER, names_to = "Cell_Type", values_to = "Count") %>%
        group_by(CLUSTER, Cell_Type) %>%
        summarize(Total_Count = sum(Count)) %>%
        pivot_wider(names_from = Cell_Type, values_from = Total_Count, values_fill = 0) %>%
        as.data.frame() %>%
        `rownames<-`(.[, 1]) %>%
        .[, -1, drop = FALSE] %>%
        sweep(., 2, colSums(.), "/") %>%
        t()

    sc.types <- Idents(sc.obj) %>%
        as.vector() %>%
        `names<-`(colnames(sc.obj))
    weight.mat <- cluster.summary[sc.types[rownames(netx.pred)], colnames(netx.pred)]
    netx.pred.new <- netx.pred * weight.mat + 1 / nrow(cluster.summary)
    netx.pred.new <- sweep(netx.pred.new, 1, rowSums(netx.pred.new), "/")
    return(netx.pred.new)
}

#' @title selectByProb
#'
#' @description Computes a similarity score matrix based on spatial and single-cell signature scores, adjusting for probabilities.
#' @param sp.score Matrix or data frame of ST signature scores.
#' @param sc.score Matrix or data frame of SC signature scores.
#' @return Similarity matrix where each row represents a spatial spot and each column represents a single-cell, adjusted based on computed probabilities.

selectByProb <- function(sp.score, sc.score) {
    probs <-
        {
            log2(sc.score + 1e-6) - log2(rowSums(sc.score) + ncol(sc.score) * 1e-6)
        } %>% t()
    testa <- log1p(as.matrix(sp.score + 1e-6)) / log(2)
    out.sim <- {
        as.matrix(testa) %*% as.matrix(probs)
    }
    max.vec <- apply(out.sim, 1, max)
    min.vec <- apply(out.sim, 1, min)
    out.sim <- sweep(out.sim, 1, min.vec, "-") %>% sweep(., 1, max.vec - min.vec, "/")
    return(out.sim)
}

#' @title featureSelelction
#'
#' @description Performs feature selection and data integration between spatial transcriptomics (ST) and single-cell (SC) data.
#' @param sp.obj Seurat object containing ST data.
#' @param sc.obj Seurat object containing SC data.
#' @param n.features Number of features to select for integration. Default: 3000.
#' @param verbose Boolean indicating whether to display verbose messages during processing. Default: TRUE.
#' @return A list containing integrated Seurat objects for SC (`sc.int`) and ST (`st.int`) data.

featureSelelction <- function(sp.obj, sc.obj, n.features = 3000, assay = "RNA", verbose = TRUE) {
    if (assay == "RNA") {
        DefaultAssay(sc.obj) <- "RNA"
        DefaultAssay(sp.obj) <- "Spatial"
        sp.obj <- NormalizeData(sp.obj, verbose = verbose)
        sc.obj <- NormalizeData(sc.obj, verbose = verbose)
    }
    ifnb.list <- list(SC = sc.obj, ST = sp.obj)
    features <- SelectIntegrationFeatures(object.list = ifnb.list, nfeatures = n.features, verbose = verbose)
    sc.st.anchors <- Seurat::FindTransferAnchors(
        reference = sc.obj,
        query = sp.obj,
        reference.assay = assay,
        query.assay = ifelse(assay == "RNA", "Spatial", "SCT"),
        features = features,
        reduction = "cca",
        verbose = verbose
    )
    st.data.trans <- Seurat::TransferData(
        anchorset = sc.st.anchors,
        refdata = GetAssayData(sc.obj, assay = assay, slot = "data")[features, ],
        weight.reduction = "cca",
        verbose = verbose
    )
    sp.obj@assays$transfer <- st.data.trans

    st.vv <- data.frame(sp.obj[["transfer"]]$data) %>% `colnames<-`(colnames(sp.obj))
    sc.vv <- data.frame(sc.obj[[assay]]$data[features, ]) %>% `colnames<-`(colnames(sc.obj))
    counts.temp <- cbind(st.vv, sc.vv)
    sc.st.int <- CreateSeuratObject(counts = counts.temp, assay = "traint")
    sc.st.int[["traint"]]$data <- sc.st.int[["traint"]]$counts
    sc.st.int <- ScaleData(sc.st.int, features = features, verbose = verbose) %>% RunPCA(features = features, verbose = verbose)
    sc.int <- subset(sc.st.int, cells = colnames(sc.obj))
    st.int <- subset(sc.st.int, cells = colnames(sp.obj))
    Idents(st.int) <- Idents(sp.obj)
    return(list(sc = sc.int, st = st.int))
}

#' @title mergeClusters
#'
#' @description Merge clusters in a Seurat object based on a maximum block size, integrating single-cell or spatial transcriptomics data.
#' @param sp.obj Seurat object containing single-cell or spatial transcriptomics data.
#' @param num.cells A vector of cell counts in spots.
#' @param max.block.size Numeric, the maximum size of the block for dividing the clusters. Default is 20000.
#' @return A vector of merged cluster identifiers.

mergeClusters <- function(sp.obj, num.cells, max.block.size = 20000) {
    target.counts <- lapply(levels(sp.obj), function(xx) {
        spots <- Idents(sp.obj)[Idents(sp.obj) == xx] %>% names()
        sum(num.cells[spots])
    }) %>%
        unlist() %>%
        `names<-`(levels(sp.obj))
    X <- AggregateExpression(sp.obj, assays = DefaultAssay(sp.obj), slot = "data", group.by = "seurat_clusters")[[1]]
    X <- X[VariableFeatures(sp.obj), ]
    hclust1 <- dist(t(X)) %>% hclust(.)
    cut.bins <- 2
    while (TRUE) {
        cut.cluste <- cutree(hclust1, cut.bins)
        merged.clusters <- split(names(cut.cluste), cut.cluste)
        cells.size <- lapply(merged.clusters, function(idx) sum(target.counts[idx])) %>% unlist()
        if (sum(cells.size > max.block.size) > 0) {
            cut.bins <- cut.bins + 1
        } else {
            break
        }
    }
    idx.merg <- Idents(sp.obj) %>% as.vector()
    for (xx in 1:length(merged.clusters)) {
        idx.merg[idx.merg %in% merged.clusters[[xx]]] <- as.character(-xx)
    }
    idx.merg <- as.integer(idx.merg) %>%
        abs() %>%
        {
            . - 1
        } %>%
        as.character() %>%
        `names<-`(colnames(sp.obj))
    return(idx.merg)
}


#' @title hclustPartition
#'
#' @param netx.pred A data.frame of probabilities inferred from FNN model.
#' @param sp.obj Seurat object containing ST data.
#' @param sc.obj Seurat object containing SC data.
#' @param st.prop Estimated proportions for ST spots.
#' @param num.cells A vector of cell counts in spots
#' @return A list of single cells partitioned into sub-clusters.

hclustPartition <- function(netx.pred, sp.obj, sc.obj, st.prop, num.cells) {
    sp.obj.sub <- sp.obj[, rownames(st.prop)]
    spot.sub <- colnames(sp.obj.sub)[Idents(sp.obj.sub) == "0"]
    total.cnts <- num.cells[spot.sub] %>% sum()
    re.assig <- round({
        colSums(st.prop[spot.sub, ]) / sum(colSums(st.prop[spot.sub, ]))
    } * total.cnts)
    re.assig[which.max(re.assig)] <- re.assig[which.max(re.assig)] + total.cnts - sum(re.assig)
    max.cells <- table(Idents(sc.obj))[names(re.assig)]
    diff.cnts <- re.assig - max.cells
    adj.cnts <- diff.cnts[which(diff.cnts > 0)]
    if (length(adj.cnts) > 0) {
        ii <-
            {
                -diff.cnts - sum(adj.cnts)
            } %>%
            .[order(.)] %>%
            {
                names(.)[which(. >= 0)[1]]
            }
        re.assig[ii] <- re.assig[ii] + sum(adj.cnts)
        re.assig[names(adj.cnts)] <- re.assig[names(adj.cnts)] - adj.cnts
    }
    keep.cells <- lapply(levels(sc.obj), function(xx) {
        sc.cells <- Idents(sc.obj)[Idents(sc.obj) == xx] %>% names()
        cnt <- re.assig[xx]
        if (cnt > 0) {
            netx.pred.sub <- netx.pred[sc.cells, , drop = FALSE]
            keep.cells <- rownames(netx.pred.sub)[order(-netx.pred.sub[, 1])] %>% .[1:cnt]
        } else {
            keep.cells <- NA
        }
    }) %>%
        unlist() %>%
        as.vector() %>%
        .[!is.na(.)]
    return(list("0" = keep.cells, "1" = setdiff(colnames(sc.obj), keep.cells)))
}

#' @title partitionClusters
#'
#' @description Partition single cells into sub-clusters using a deep learning strategy based on integration of spatial transcriptomics (ST) and single-cell (SC) data.
#' @param sp.obj Seurat object containing ST data.
#' @param sc.obj Seurat object containing SC data.
#' @param num.cells A vector of cell counts in spots.
#' @param hot.spts Data frame indicating hotspot presence in spots and cell types.
#' @param hclust Logical. If TRUE, hierarchical clustering is applied to group ST clusters. Default: TRUE.
#' @param st.prop Estimated proportions for ST spots.
#' @return A list of single cells partitioned into sub-clusters.
#' @export partitionClusters

partitionClusters <- function(sp.obj, sc.obj, num.cells, hot.spts, st.prop, hclust = TRUE) {
    sc.st.int <- featureSelelction(sp.obj, sc.obj, verbose = FALSE)
    sc.int <- sc.st.int$sc
    sp.int <- sc.st.int$st
    python.script <- system.file("python/netx.py", package = "Cell2Spatial")
    command <- ifelse(.Platform$OS.type == "windows", "where", "which")
    py.path <- system(sprintf("%s python", command), intern = TRUE)[1]
    reticulate::use_python(py.path)
    source_python(python.script)

    sp.embeddings <- sp.int@reductions$pca@cell.embeddings[, 1:30]
    sc.embeddings <- sc.int@reductions$pca@cell.embeddings[, 1:30]
    if (hclust) {
        labels <- mergeClusters(sp.obj, num.cells)
        Idents(sp.obj) <- labels
        levels(sp.obj) <- unique(labels) %>% stringr::str_sort(., numeric = TRUE)
    } else {
        labels <- Idents(sp.int) %>%
            as.vector() %>%
            as.integer()
    }
    netx.pred <- runNetModel(sc.embeddings, sp.embeddings, as.integer(labels), epochs = 1000) %>%
        `rownames<-`(colnames(sc.int)) %>%
        `colnames<-`(levels(sp.obj))
    if (hclust && length(levels(sc.obj)) > 1 && length(levels(sp.obj)) == 2) {
        index.lst <- hclustPartition(netx.pred, sp.obj, sc.obj, st.prop, num.cells)
        return(list(PARTION = index.lst, CLUSTER = labels))
    }

    target.counts <- lapply(levels(sp.obj), function(xx) {
        spots <- Idents(sp.obj)[Idents(sp.obj) == xx] %>% names()
        sum(num.cells[spots])
    }) %>%
        unlist() %>%
        `names<-`(levels(sp.obj))

    # netx.pred <- weigthNetProb(netx.pred, sc.obj, sp.obj, hot.spts)
    netx.pred.scale <- sweep(netx.pred, MARGIN = 1, apply(netx.pred, 1, max), "/")
    max.idxes <- apply(netx.pred, 1, which.max) %>%
        colnames(netx.pred)[.] %>%
        `names<-`(rownames(netx.pred))
    pred.counts <- rep(0, length(levels(sp.obj))) %>% `names<-`(levels(sp.obj))
    pred.counts[names(table(max.idxes))] <- table(max.idxes)
    cell.diff <- pred.counts - target.counts

    index.lst <- list()
    flag.id <- flag.id.update <- c()
    while (any(cell.diff) > 0) {
        for (cluster in setdiff(names(target.counts), flag.id.update)) {
            if (cell.diff[cluster] > 0) {
                tmp.index <- netx.pred[, cluster] %>%
                    `names<-`(rownames(netx.pred)) %>%
                    .[order(.) %>% rev()]
                index.lst[[cluster]] <- netx.pred.scale[, cluster] %>%
                    `names<-`(rownames(netx.pred.scale)) %>%
                    .[names(tmp.index)] %>%
                    {
                        .[. == 1]
                    } %>%
                    .[1:target.counts[cluster]] %>%
                    names()
                flag.id <- c(flag.id, cluster)
                pred.counts[cluster] <- target.counts[cluster]
            }
        }
        remain.cells <- setdiff(rownames(netx.pred), unlist(index.lst))
        if (length(setdiff(colnames(netx.pred), flag.id)) == 0) break
        netx.pred <- netx.pred[remain.cells, setdiff(colnames(netx.pred), flag.id), drop = FALSE]
        netx.pred <- sweep(netx.pred, MARGIN = 1, rowSums(netx.pred), "/")
        netx.pred.scale <- sweep(netx.pred, MARGIN = 1, apply(netx.pred, 1, max), "/")
        max.idxes <- apply(netx.pred, 1, which.max) %>%
            colnames(netx.pred)[.] %>%
            `names<-`(rownames(netx.pred))
        pred.counts[names(table(max.idxes))] <- table(max.idxes)
        cell.diff <- pred.counts - target.counts
        flag.id.update <- c(flag.id.update, flag.id)
        flag.id <- c()
    }
    diff.ct <- setdiff(names(target.counts), names(index.lst))
    if (length(diff.ct) > 0) {
        index.lst[[diff.ct]] <- setdiff(colnames(sc.int), unlist(index.lst))
    }
    index.lst <- index.lst[names(target.counts)]
    return(list(PARTION = index.lst, CLUSTER = labels))
}

#' @title linearSumAssignment
#'
#' @description Assigns single cells to spatial coordinates based on similarity scores between single-cell and spatial transcriptomics (ST) data.
#' @param sp.obj Seurat object containing ST data.
#' @param sc.obj Seurat object containing SC data.
#' @param out.sim Similarity matrix between single cells and spots.
#' @param adj.w Weight matrix for adjusting similarity scores.
#' @param num.cells A vector indicating the cell count per spot projected to spots.
#' @param hot.spts Data frame indicating hotspot presence in spots and cell types.
#' @param st.prop Estimated proportions for ST spots.
#' @param partition Logical indicating whether to split into sub-modules mapped to spatial positions.
#' @param hclust Logical. If TRUE, hierarchical clustering is applied to group ST clusters. Default: TRUE.
#' @return A list of assigned cells corresponding to spots.
#' @export linearSumAssignment

linearSumAssignment <- function(sp.obj, sc.obj, out.sim, adj.w, num.cells, hot.spts, st.prop, partition, hclust = TRUE) {
    if (partition) {
        index.lst <- partitionClusters(sp.obj, sc.obj, num.cells, hot.spts, st.prop, hclust = hclust)
    } else {
        if (nrow(out.sim) > 30000) {
            index.lst <- partitionClusters(sp.obj, sc.obj, num.cells, hot.spts, st.prop, hclust = hclust)
        } else {
            index.lst <- list(ENTIRE = NULL)
        }
    }
    if ("PARTION" %in% names(index.lst)) {
        cls.labels <- index.lst$CLUSTER
        index.lst <- index.lst$PARTION
        Idents(sp.obj) <- cls.labels
    }
    assign.res <- future.apply::future_lapply(names(index.lst), function(cls) {
        if (cls != "ENTIRE") {
            spot.sub <- colnames(sp.obj)[Idents(sp.obj) == cls]
            out.sim.sub <- out.sim[spot.sub, index.lst[[cls]]]
        } else {
            out.sim.sub <- out.sim
        }
        spot.name <- Idents(sp.obj)[rownames(out.sim.sub)]
        cell.names <- Idents(sc.obj)[colnames(out.sim.sub)]
        out.sim.sub <- weightSimScore(out.sim.sub, adj.w, spot.name, cell.names, hot.spts)

        tmp.dir <- tempdir()
        sim.file <- file.path(tmp.dir, sprintf("sim_%s.xls", cls))
        num.file <- file.path(tmp.dir, sprintf("num_%s.xls", cls))
        data.table::fwrite(as.data.frame(out.sim.sub) * (-1), file = sim.file)
        data.table::fwrite(as.data.frame(num.cells[colnames(out.sim.sub)]), file = num.file)

        python.script <- system.file("python/solve.py", package = "Cell2Spatial")
        system(sprintf("python %s %s %s %s %s", python.script, tmp.dir, sim.file, num.file, cls))

        index <- read.table(file.path(tmp.dir, paste0(cls, "_output.txt"))) + 1
        spot.ids <- colnames(out.sim.sub)[index[, 1]]
        cbind.data.frame(CELL = rownames(out.sim.sub), SPOT = spot.ids)
    }, future.seed = TRUE) %>%
        do.call(rbind, .) %>%
        as.data.frame()
    out.sc <- split(assign.res$CELL, assign.res$SPOT)
    out.sc <- out.sc[colnames(sp.obj)]
    return(out.sc)
}
