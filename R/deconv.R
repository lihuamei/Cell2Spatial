#' @title estPropInSpots
#'
#' @description Infer cellular proportions for spatial transcriptome (ST) spots.
#'
#' @param sp.obj Seurat object of ST data.
#' @param sc.obj Seurat object of single-cell (SC) data.
#' @param sc.markers A list of markers of cell types.
#' @param hot.pvals A data.frame containing p-values generated by hotspot detection step. Default: NULL.
#' @param weight Weighting scheme for hotspot-informed adjustment of spot–cell-type contributions. "Scales": rescales hotspot significance within tissue identities. "NONE": applies no weighting. Default: Scales.
#' @param assay The assay to use for SC data. Default: "SCT" (Seurat's SCTransform).
#' @param knn K nearest cells used for estimating cellular proportions. Default: 5.
#' @param intercept Boolean indicating whether to use intercept for robust linear regression. Default: TRUE.
#' @return A data.frame of estimated cellular proportions in spots.

estPropInSpots <- function(sp.obj, sc.obj, sc.markers, num.cells = NULL, hot.pvals = NULL, weight = c("Scales", "NONE"), assay = "SCT", knn = 5, intercept = TRUE) {
    base.ref <-
        {
            AverageExpression(sc.obj, slot = "data", assay = assay)[[assay]]
        } %>%
        {
            .[unlist(sc.markers) %>% unique(), ]
        } %>%
        {
            log10(. + 1)
        }
    knn.new <- ifelse(knn == 0, 1, knn)
    image.coord <- GetTissueCoordinates(sp.obj)[colnames(sp.obj), ]
    dist.lst <- lapply(levels(sp.obj), function(ident) {
        image.coord.tmp <- image.coord[Idents(sp.obj)[Idents(sp.obj) == ident] %>% names(), , drop = FALSE]
        dist.mat <- dbscan::kNN(na.omit(image.coord.tmp[, c(1, 2)]), k = min(knn.new, nrow(image.coord.tmp)))$id
    }) %>% `names<-`(levels(sp.obj))

    assay.sp <- ifelse(assay == "SCT", assay, "Spatial")
    sp.expr <- GetAssayData(sp.obj, slot = "data", assay = assay.sp)[rownames(base.ref), ]
    cell.types <- colnames(base.ref)
    colnames(base.ref) <- gsub(" |/|\\+|-|\\(|\\)|,", "_", colnames(base.ref))

    tar.spots <- colnames(sp.obj)
    if (!is.null(hot.pvals) & weight != "NONE") {
        w.mat.1 <- permuteWthreshold(sp.obj, hot.pvals[, cell.types, drop = FALSE], num.cells)
        w.mat.2 <- ctypesOfClusters(sp.obj, hot.pvals)
        w.mat <- w.mat.1[rownames(w.mat.2), ] + w.mat.2
        w.mat <- w.mat == 2
    } else {
        w.mat <- matrix(TRUE, ncol = length(sc.markers), nrow = levels(sp.obj) %>% length(), dimnames = list(levels(sp.obj), names(sc.markers)))
    }
    print(w.mat)
    colnames(base.ref) <- paste0("X", colnames(base.ref))
    spot.prop <- future.apply::future_lapply(tar.spots, function(spot) {
        dist.mat <- dist.lst[[Idents(sp.obj)[spot]]]
        knn.spots <- dist.mat[spot, ] %>%
            rownames(dist.mat)[.] %>%
            c(spot, .) %>%
            .[1:(knn + 1)]
        sp.expr.sub <- sp.expr[, knn.spots] %>%
            {
                10^.
            } %>%
            as.data.frame() %>%
            rowMeans() %>%
            {
                log10(.)
            }
        dat <- cbind.data.frame(base.ref, Bulk = sp.expr.sub)
        if (intercept) {
            w.coefs <- coef(MASS::rlm(Bulk ~ ., dat, maxit = 2000))
        } else {
            w.coefs <- coef(MASS::rlm(Bulk ~ . - 1, dat, maxit = 2000))
        }
        w.coefs[w.coefs < 0] <- 0
        coefs <- w.coefs[(intercept + 1):length(w.coefs)] / sum(w.coefs[(intercept + 1):length(w.coefs)])
        coefs <- coefs * w.mat[as.vector(Idents(sp.obj)[spot]), cell.types]
        names(coefs) <- cell.types
        if (all(is.na(coefs))) {
            coefs[] <- 1 / length(coefs)
        } else {
            if (all(coefs == 0)) {
                idxes <- which(w.mat[as.vector(Idents(sp.obj)[spot]), cell.types] == TRUE)
                coefs[idxes] <- 1 / length(idxes)
            }
        }
        coefs <- coefs / sum(coefs)
        return(coefs)
    }, future.seed = TRUE) %>%
        do.call(rbind, .) %>%
        as.data.frame() %>%
        `rownames<-`(tar.spots) %>%
        `colnames<-`(cell.types)
    spot.prop <- spot.prop[!is.na(rowSums(spot.prop)), ]
    return(spot.prop)
}

.estPropInSpots <- function(sp.score, max.cells.in.spot = 10, platform.res = "Low", partition = FALSE, ...) {
    dots <- list(...)
    sc.markers <- dots$sc.markers
    num.cells <- dots$num.cells
    if (platform.res == "Low") {
        if (length(sc.markers) > 1) {
            st.prop <- estPropInSpots(...)
        } else {
            st.prop <- binarizeMax(sp.score)
        }
    } else {
        st.prop <- binarizeMax(sp.score)
    }
    if (partition || sum(num.cells) > 30000L) {
        st.prop.cnts <- prop2counts(st.prop, num.cells[rownames(st.prop)])
    } else {
        st.prop.cnts <- roundCountsUseProp(st.prop, num.cells)
    }
    return(list(cnts = st.prop.cnts, props = st.prop))
}

#' @title computeWtopk
#'
#' @description Compute cluster-level weights after per-spot Top-k selection with a p-value cutoff.
#'
#' @param sp.obj Seurat object containing the spots.
#' @param hot.pvals Numeric matrix/data frame of p-values with rows = spots and columns = features.
#' @param num.cells Named integer/numeric vector giving, for each spot, the number of cells in that spot (the k used for Top-k).
#' @param p.cut Numeric scalar in (0, 1]; only p-values ≤ this threshold are eligible for the Top-k selection within each spot. Default: 0.05.
#' @return A numeric matrix `w` of size (#clusters × #features). Each row (cluster) sums to 1

computeWtopk <- function(sp.obj, hot.pvals, num.cells, p.cut = 0.05) {
    hot.pvals <- as.matrix(hot.pvals)
    num.cells <- num.cells[rownames(hot.pvals)]
    ranks <- matrixStats::rowRanks(hot.pvals, ties.method = "min")
    k.mat <- matrix(num.cells, nrow = nrow(hot.pvals), ncol = ncol(hot.pvals))
    mask <- (hot.pvals <= p.cut) & (ranks <= k.mat)
    clv <- as.character(Idents(sp.obj)[rownames(hot.pvals)])

    cnt.mat <- rowsum(mask * 1L, group = clv, reorder = TRUE)
    den <- rowSums(cnt.mat)
    den.safe <- ifelse(den == 0, 1, den)
    w <- sweep(cnt.mat, 1, den.safe, "/")
    w[den == 0, ] <- 0
    w <- as.matrix(w)
    dimnames(w) <- list(rownames(cnt.mat), colnames(cnt.mat))
    return(w)
}

#' @title permuteWthreshold
#'
#' @description Build an empirical, per-cell cutoff via permutation.
#'
#' @param sp.obj Seurat object.
#' @param hot.pvals Numeric matrix/data frame of p-values.
#' @param num.cells Named vector of per-spot cell counts (Top-k).
#' @param p.cut Numeric scalar in (0, 1]; p-value cutoff used inside `computeWtopk()` for Top-k selection. Default: 0.05.
#' @param B Integer; number of permutations to generate the null distribution. Default: 200.
#' @param q Numeric in (0, 1); quantile of the null distribution used as the cutoff. Default: 0.95.
#' @return A logical matrix `w.mat` (clusters × features).

permuteWthreshold <- function(sp.obj, hot.pvals, num.cells, p.cut = 0.05, B = 200, q = 0.95) {
    set.seed(1L)
    w.obs <- computeWtopk(sp.obj, hot.pvals, num.cells, p.cut = p.cut)
    nr <- nrow(hot.pvals)
    nc <- ncol(hot.pvals)
    null.list <- vector("list", B)
    for (b in seq_len(B)) {
        hp <- apply(hot.pvals, 2, function(x) x[sample.int(nr)])
        hp <- apply(hp, 1, function(x) x[sample.int(nc)]) %>% t()
        dimnames(hp) <- dimnames(hot.pvals)
        wb <- computeWtopk(sp.obj, hp, num.cells, p.cut = p.cut)
        null.list[[b]] <- wb
    }
    null.arr2 <- simplify2array(null.list)
    w.cut.mat <- apply(null.arr2, c(1, 2), quantile, probs = q, type = 8, na.rm = TRUE)
    w.mat <-
        {
            w.obs - w.cut.mat
        } %>% {
            . > 0
        }
    idx <- which(rowSums(w.mat) == 0)
    if (length(idx) > 0) {
        w.mat[idx, ] <- TRUE
    }
    return(w.mat)
}

#' @title ctypesOfClusters
#'
#' @description Calculates weighted scores of cellular types across clusters based on spatial transcriptomics (ST) data and hotspot information.
#' @param sp.obj Seurat object of ST data.
#' @param hot.pvals A data.frame containing p-values generated by hotspot detection step.
#' @param p.cut Threashold value to filter out low-condfi
#' @return A data frame where each row represents a cluster and each column represents a cellular type, with values indicating weighted scores.

ctypesOfClusters <- function(sp.obj, hot.pvals, p.cut = 0.05) {
    hot.spts.tp <- hot.pvals < p.cut
    w.mat <- lapply(levels(sp.obj), function(cls) {
        spots <- colnames(sp.obj)[Idents(sp.obj) == cls]
        sub.pvals <- hot.spts.tp[spots, ]
        if (length(spots) > 1) {
            tmp.cnt <- colSums(sub.pvals)
        } else {
            tmp.cnt <- sum(sub.pvals)
        }
        w.gs <- scales::rescale(tmp.cnt %>% as.numeric(), to = c(0, 1))
    }) %>%
        do.call(rbind, .) %>%
        as.data.frame() %>%
        `rownames<-`(levels(sp.obj)) %>%
        `colnames<-`(colnames(hot.spts.tp))
    w.mat <- ifelse(w.mat < 0.01, 0, 1)
    return(w.mat)
}
